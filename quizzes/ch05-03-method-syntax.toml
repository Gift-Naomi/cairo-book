[[questions]]
type = "Tracing"
prompt.program = """
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -> u64 {
        (*self.width) * (*self.height)
    }
    fn new(width: u64, height: u64) -> Rectangle {
        Rectangle { width, height }
    }
    fn compare(self: @Rectangle, r2: @Rectangle) -> bool {
        let r1_area = self.area();
        self.area() == r2.area()
    }
}

fn main() {
    let rect1 = Rectangle {width: 40, height: 50};
    let rect2 = RectangleTrait::new(10, 40);;
    rect1.compare(@rect2);
}
"""

answer.doesCompile = true
answer.stdout = "false"
context = """
It compiles, because the type `Rectangle` on which we call the method on reference is implicitly passed as a `@Rectangle`
"""



[[questions]]
type = "Tracing"
prompt.program = """
#[derive(Drop)]
struct Square {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn area(self: @Rectangle) -> u64;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -> u64 {
        return (*self.width) * (*self.height);
    }
}

fn main() {
    let my_square = Square { width: 30, height: 50 };
    let area = my_square.area();
    assert!(area == 1500);
}
"""
answer.doesCompile = false
context = """
Methods can only be called on the types they're defined for; here, we try to call `area()` on `Square`, when it's define for `Rectangle`.
"""
